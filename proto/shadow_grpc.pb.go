// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.23.2
// source: proto/shadow.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Switch_Route_FullMethodName   = "/msg.Switch/Route"
	Switch_Command_FullMethodName = "/msg.Switch/Command"
	Switch_Lookup_FullMethodName  = "/msg.Switch/Lookup"
)

// SwitchClient is the client API for Switch service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SwitchClient interface {
	Route(ctx context.Context, opts ...grpc.CallOption) (Switch_RouteClient, error)
	Command(ctx context.Context, in *Data, opts ...grpc.CallOption) (*Status, error)
	Lookup(ctx context.Context, in *Data, opts ...grpc.CallOption) (*Data, error)
}

type switchClient struct {
	cc grpc.ClientConnInterface
}

func NewSwitchClient(cc grpc.ClientConnInterface) SwitchClient {
	return &switchClient{cc}
}

func (c *switchClient) Route(ctx context.Context, opts ...grpc.CallOption) (Switch_RouteClient, error) {
	stream, err := c.cc.NewStream(ctx, &Switch_ServiceDesc.Streams[0], Switch_Route_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &switchRouteClient{stream}
	return x, nil
}

type Switch_RouteClient interface {
	Send(*Transaction) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type switchRouteClient struct {
	grpc.ClientStream
}

func (x *switchRouteClient) Send(m *Transaction) error {
	return x.ClientStream.SendMsg(m)
}

func (x *switchRouteClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *switchClient) Command(ctx context.Context, in *Data, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, Switch_Command_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *switchClient) Lookup(ctx context.Context, in *Data, opts ...grpc.CallOption) (*Data, error) {
	out := new(Data)
	err := c.cc.Invoke(ctx, Switch_Lookup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SwitchServer is the server API for Switch service.
// All implementations must embed UnimplementedSwitchServer
// for forward compatibility
type SwitchServer interface {
	Route(Switch_RouteServer) error
	Command(context.Context, *Data) (*Status, error)
	Lookup(context.Context, *Data) (*Data, error)
	mustEmbedUnimplementedSwitchServer()
}

// UnimplementedSwitchServer must be embedded to have forward compatible implementations.
type UnimplementedSwitchServer struct {
}

func (UnimplementedSwitchServer) Route(Switch_RouteServer) error {
	return status.Errorf(codes.Unimplemented, "method Route not implemented")
}
func (UnimplementedSwitchServer) Command(context.Context, *Data) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Command not implemented")
}
func (UnimplementedSwitchServer) Lookup(context.Context, *Data) (*Data, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lookup not implemented")
}
func (UnimplementedSwitchServer) mustEmbedUnimplementedSwitchServer() {}

// UnsafeSwitchServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SwitchServer will
// result in compilation errors.
type UnsafeSwitchServer interface {
	mustEmbedUnimplementedSwitchServer()
}

func RegisterSwitchServer(s grpc.ServiceRegistrar, srv SwitchServer) {
	s.RegisterService(&Switch_ServiceDesc, srv)
}

func _Switch_Route_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SwitchServer).Route(&switchRouteServer{stream})
}

type Switch_RouteServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*Transaction, error)
	grpc.ServerStream
}

type switchRouteServer struct {
	grpc.ServerStream
}

func (x *switchRouteServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *switchRouteServer) Recv() (*Transaction, error) {
	m := new(Transaction)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Switch_Command_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Data)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwitchServer).Command(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Switch_Command_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwitchServer).Command(ctx, req.(*Data))
	}
	return interceptor(ctx, in, info, handler)
}

func _Switch_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Data)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwitchServer).Lookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Switch_Lookup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwitchServer).Lookup(ctx, req.(*Data))
	}
	return interceptor(ctx, in, info, handler)
}

// Switch_ServiceDesc is the grpc.ServiceDesc for Switch service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Switch_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Switch",
	HandlerType: (*SwitchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Command",
			Handler:    _Switch_Command_Handler,
		},
		{
			MethodName: "Lookup",
			Handler:    _Switch_Lookup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Route",
			Handler:       _Switch_Route_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_1_Send_FullMethodName = "/msg.Proxy_1/Send"
)

// Proxy_1Client is the client API for Proxy_1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_1Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_1Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_1Client(cc grpc.ClientConnInterface) Proxy_1Client {
	return &proxy_1Client{cc}
}

func (c *proxy_1Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_1_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_1Server is the server API for Proxy_1 service.
// All implementations must embed UnimplementedProxy_1Server
// for forward compatibility
type Proxy_1Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_1Server()
}

// UnimplementedProxy_1Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_1Server struct {
}

func (UnimplementedProxy_1Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_1Server) mustEmbedUnimplementedProxy_1Server() {}

// UnsafeProxy_1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_1Server will
// result in compilation errors.
type UnsafeProxy_1Server interface {
	mustEmbedUnimplementedProxy_1Server()
}

func RegisterProxy_1Server(s grpc.ServiceRegistrar, srv Proxy_1Server) {
	s.RegisterService(&Proxy_1_ServiceDesc, srv)
}

func _Proxy_1_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_1Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_1_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_1Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_1_ServiceDesc is the grpc.ServiceDesc for Proxy_1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_1_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_1",
	HandlerType: (*Proxy_1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_1_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_2_Send_FullMethodName = "/msg.Proxy_2/Send"
)

// Proxy_2Client is the client API for Proxy_2 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_2Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_2Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_2Client(cc grpc.ClientConnInterface) Proxy_2Client {
	return &proxy_2Client{cc}
}

func (c *proxy_2Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_2_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_2Server is the server API for Proxy_2 service.
// All implementations must embed UnimplementedProxy_2Server
// for forward compatibility
type Proxy_2Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_2Server()
}

// UnimplementedProxy_2Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_2Server struct {
}

func (UnimplementedProxy_2Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_2Server) mustEmbedUnimplementedProxy_2Server() {}

// UnsafeProxy_2Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_2Server will
// result in compilation errors.
type UnsafeProxy_2Server interface {
	mustEmbedUnimplementedProxy_2Server()
}

func RegisterProxy_2Server(s grpc.ServiceRegistrar, srv Proxy_2Server) {
	s.RegisterService(&Proxy_2_ServiceDesc, srv)
}

func _Proxy_2_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_2Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_2_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_2Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_2_ServiceDesc is the grpc.ServiceDesc for Proxy_2 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_2_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_2",
	HandlerType: (*Proxy_2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_2_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_3_Send_FullMethodName = "/msg.Proxy_3/Send"
)

// Proxy_3Client is the client API for Proxy_3 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_3Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_3Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_3Client(cc grpc.ClientConnInterface) Proxy_3Client {
	return &proxy_3Client{cc}
}

func (c *proxy_3Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_3_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_3Server is the server API for Proxy_3 service.
// All implementations must embed UnimplementedProxy_3Server
// for forward compatibility
type Proxy_3Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_3Server()
}

// UnimplementedProxy_3Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_3Server struct {
}

func (UnimplementedProxy_3Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_3Server) mustEmbedUnimplementedProxy_3Server() {}

// UnsafeProxy_3Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_3Server will
// result in compilation errors.
type UnsafeProxy_3Server interface {
	mustEmbedUnimplementedProxy_3Server()
}

func RegisterProxy_3Server(s grpc.ServiceRegistrar, srv Proxy_3Server) {
	s.RegisterService(&Proxy_3_ServiceDesc, srv)
}

func _Proxy_3_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_3Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_3_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_3Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_3_ServiceDesc is the grpc.ServiceDesc for Proxy_3 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_3_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_3",
	HandlerType: (*Proxy_3Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_3_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_4_Send_FullMethodName = "/msg.Proxy_4/Send"
)

// Proxy_4Client is the client API for Proxy_4 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_4Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_4Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_4Client(cc grpc.ClientConnInterface) Proxy_4Client {
	return &proxy_4Client{cc}
}

func (c *proxy_4Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_4_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_4Server is the server API for Proxy_4 service.
// All implementations must embed UnimplementedProxy_4Server
// for forward compatibility
type Proxy_4Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_4Server()
}

// UnimplementedProxy_4Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_4Server struct {
}

func (UnimplementedProxy_4Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_4Server) mustEmbedUnimplementedProxy_4Server() {}

// UnsafeProxy_4Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_4Server will
// result in compilation errors.
type UnsafeProxy_4Server interface {
	mustEmbedUnimplementedProxy_4Server()
}

func RegisterProxy_4Server(s grpc.ServiceRegistrar, srv Proxy_4Server) {
	s.RegisterService(&Proxy_4_ServiceDesc, srv)
}

func _Proxy_4_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_4Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_4_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_4Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_4_ServiceDesc is the grpc.ServiceDesc for Proxy_4 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_4_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_4",
	HandlerType: (*Proxy_4Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_4_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_5_Send_FullMethodName = "/msg.Proxy_5/Send"
)

// Proxy_5Client is the client API for Proxy_5 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_5Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_5Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_5Client(cc grpc.ClientConnInterface) Proxy_5Client {
	return &proxy_5Client{cc}
}

func (c *proxy_5Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_5_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_5Server is the server API for Proxy_5 service.
// All implementations must embed UnimplementedProxy_5Server
// for forward compatibility
type Proxy_5Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_5Server()
}

// UnimplementedProxy_5Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_5Server struct {
}

func (UnimplementedProxy_5Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_5Server) mustEmbedUnimplementedProxy_5Server() {}

// UnsafeProxy_5Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_5Server will
// result in compilation errors.
type UnsafeProxy_5Server interface {
	mustEmbedUnimplementedProxy_5Server()
}

func RegisterProxy_5Server(s grpc.ServiceRegistrar, srv Proxy_5Server) {
	s.RegisterService(&Proxy_5_ServiceDesc, srv)
}

func _Proxy_5_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_5Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_5_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_5Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_5_ServiceDesc is the grpc.ServiceDesc for Proxy_5 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_5_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_5",
	HandlerType: (*Proxy_5Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_5_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_6_Send_FullMethodName = "/msg.Proxy_6/Send"
)

// Proxy_6Client is the client API for Proxy_6 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_6Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_6Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_6Client(cc grpc.ClientConnInterface) Proxy_6Client {
	return &proxy_6Client{cc}
}

func (c *proxy_6Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_6_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_6Server is the server API for Proxy_6 service.
// All implementations must embed UnimplementedProxy_6Server
// for forward compatibility
type Proxy_6Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_6Server()
}

// UnimplementedProxy_6Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_6Server struct {
}

func (UnimplementedProxy_6Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_6Server) mustEmbedUnimplementedProxy_6Server() {}

// UnsafeProxy_6Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_6Server will
// result in compilation errors.
type UnsafeProxy_6Server interface {
	mustEmbedUnimplementedProxy_6Server()
}

func RegisterProxy_6Server(s grpc.ServiceRegistrar, srv Proxy_6Server) {
	s.RegisterService(&Proxy_6_ServiceDesc, srv)
}

func _Proxy_6_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_6Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_6_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_6Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_6_ServiceDesc is the grpc.ServiceDesc for Proxy_6 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_6_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_6",
	HandlerType: (*Proxy_6Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_6_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_7_Send_FullMethodName = "/msg.Proxy_7/Send"
)

// Proxy_7Client is the client API for Proxy_7 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_7Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_7Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_7Client(cc grpc.ClientConnInterface) Proxy_7Client {
	return &proxy_7Client{cc}
}

func (c *proxy_7Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_7_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_7Server is the server API for Proxy_7 service.
// All implementations must embed UnimplementedProxy_7Server
// for forward compatibility
type Proxy_7Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_7Server()
}

// UnimplementedProxy_7Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_7Server struct {
}

func (UnimplementedProxy_7Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_7Server) mustEmbedUnimplementedProxy_7Server() {}

// UnsafeProxy_7Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_7Server will
// result in compilation errors.
type UnsafeProxy_7Server interface {
	mustEmbedUnimplementedProxy_7Server()
}

func RegisterProxy_7Server(s grpc.ServiceRegistrar, srv Proxy_7Server) {
	s.RegisterService(&Proxy_7_ServiceDesc, srv)
}

func _Proxy_7_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_7Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_7_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_7Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_7_ServiceDesc is the grpc.ServiceDesc for Proxy_7 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_7_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_7",
	HandlerType: (*Proxy_7Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_7_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_8_Send_FullMethodName = "/msg.Proxy_8/Send"
)

// Proxy_8Client is the client API for Proxy_8 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_8Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_8Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_8Client(cc grpc.ClientConnInterface) Proxy_8Client {
	return &proxy_8Client{cc}
}

func (c *proxy_8Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_8_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_8Server is the server API for Proxy_8 service.
// All implementations must embed UnimplementedProxy_8Server
// for forward compatibility
type Proxy_8Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_8Server()
}

// UnimplementedProxy_8Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_8Server struct {
}

func (UnimplementedProxy_8Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_8Server) mustEmbedUnimplementedProxy_8Server() {}

// UnsafeProxy_8Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_8Server will
// result in compilation errors.
type UnsafeProxy_8Server interface {
	mustEmbedUnimplementedProxy_8Server()
}

func RegisterProxy_8Server(s grpc.ServiceRegistrar, srv Proxy_8Server) {
	s.RegisterService(&Proxy_8_ServiceDesc, srv)
}

func _Proxy_8_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_8Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_8_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_8Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_8_ServiceDesc is the grpc.ServiceDesc for Proxy_8 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_8_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_8",
	HandlerType: (*Proxy_8Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_8_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_9_Send_FullMethodName = "/msg.Proxy_9/Send"
)

// Proxy_9Client is the client API for Proxy_9 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_9Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_9Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_9Client(cc grpc.ClientConnInterface) Proxy_9Client {
	return &proxy_9Client{cc}
}

func (c *proxy_9Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_9_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_9Server is the server API for Proxy_9 service.
// All implementations must embed UnimplementedProxy_9Server
// for forward compatibility
type Proxy_9Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_9Server()
}

// UnimplementedProxy_9Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_9Server struct {
}

func (UnimplementedProxy_9Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_9Server) mustEmbedUnimplementedProxy_9Server() {}

// UnsafeProxy_9Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_9Server will
// result in compilation errors.
type UnsafeProxy_9Server interface {
	mustEmbedUnimplementedProxy_9Server()
}

func RegisterProxy_9Server(s grpc.ServiceRegistrar, srv Proxy_9Server) {
	s.RegisterService(&Proxy_9_ServiceDesc, srv)
}

func _Proxy_9_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_9Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_9_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_9Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_9_ServiceDesc is the grpc.ServiceDesc for Proxy_9 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_9_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_9",
	HandlerType: (*Proxy_9Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_9_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_10_Send_FullMethodName = "/msg.Proxy_10/Send"
)

// Proxy_10Client is the client API for Proxy_10 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_10Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_10Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_10Client(cc grpc.ClientConnInterface) Proxy_10Client {
	return &proxy_10Client{cc}
}

func (c *proxy_10Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_10_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_10Server is the server API for Proxy_10 service.
// All implementations must embed UnimplementedProxy_10Server
// for forward compatibility
type Proxy_10Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_10Server()
}

// UnimplementedProxy_10Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_10Server struct {
}

func (UnimplementedProxy_10Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_10Server) mustEmbedUnimplementedProxy_10Server() {}

// UnsafeProxy_10Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_10Server will
// result in compilation errors.
type UnsafeProxy_10Server interface {
	mustEmbedUnimplementedProxy_10Server()
}

func RegisterProxy_10Server(s grpc.ServiceRegistrar, srv Proxy_10Server) {
	s.RegisterService(&Proxy_10_ServiceDesc, srv)
}

func _Proxy_10_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_10Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_10_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_10Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_10_ServiceDesc is the grpc.ServiceDesc for Proxy_10 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_10_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_10",
	HandlerType: (*Proxy_10Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_10_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_11_Send_FullMethodName = "/msg.Proxy_11/Send"
)

// Proxy_11Client is the client API for Proxy_11 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_11Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_11Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_11Client(cc grpc.ClientConnInterface) Proxy_11Client {
	return &proxy_11Client{cc}
}

func (c *proxy_11Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_11_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_11Server is the server API for Proxy_11 service.
// All implementations must embed UnimplementedProxy_11Server
// for forward compatibility
type Proxy_11Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_11Server()
}

// UnimplementedProxy_11Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_11Server struct {
}

func (UnimplementedProxy_11Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_11Server) mustEmbedUnimplementedProxy_11Server() {}

// UnsafeProxy_11Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_11Server will
// result in compilation errors.
type UnsafeProxy_11Server interface {
	mustEmbedUnimplementedProxy_11Server()
}

func RegisterProxy_11Server(s grpc.ServiceRegistrar, srv Proxy_11Server) {
	s.RegisterService(&Proxy_11_ServiceDesc, srv)
}

func _Proxy_11_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_11Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_11_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_11Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_11_ServiceDesc is the grpc.ServiceDesc for Proxy_11 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_11_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_11",
	HandlerType: (*Proxy_11Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_11_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_12_Send_FullMethodName = "/msg.Proxy_12/Send"
)

// Proxy_12Client is the client API for Proxy_12 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_12Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_12Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_12Client(cc grpc.ClientConnInterface) Proxy_12Client {
	return &proxy_12Client{cc}
}

func (c *proxy_12Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_12_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_12Server is the server API for Proxy_12 service.
// All implementations must embed UnimplementedProxy_12Server
// for forward compatibility
type Proxy_12Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_12Server()
}

// UnimplementedProxy_12Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_12Server struct {
}

func (UnimplementedProxy_12Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_12Server) mustEmbedUnimplementedProxy_12Server() {}

// UnsafeProxy_12Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_12Server will
// result in compilation errors.
type UnsafeProxy_12Server interface {
	mustEmbedUnimplementedProxy_12Server()
}

func RegisterProxy_12Server(s grpc.ServiceRegistrar, srv Proxy_12Server) {
	s.RegisterService(&Proxy_12_ServiceDesc, srv)
}

func _Proxy_12_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_12Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_12_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_12Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_12_ServiceDesc is the grpc.ServiceDesc for Proxy_12 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_12_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_12",
	HandlerType: (*Proxy_12Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_12_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_13_Send_FullMethodName = "/msg.Proxy_13/Send"
)

// Proxy_13Client is the client API for Proxy_13 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_13Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_13Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_13Client(cc grpc.ClientConnInterface) Proxy_13Client {
	return &proxy_13Client{cc}
}

func (c *proxy_13Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_13_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_13Server is the server API for Proxy_13 service.
// All implementations must embed UnimplementedProxy_13Server
// for forward compatibility
type Proxy_13Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_13Server()
}

// UnimplementedProxy_13Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_13Server struct {
}

func (UnimplementedProxy_13Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_13Server) mustEmbedUnimplementedProxy_13Server() {}

// UnsafeProxy_13Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_13Server will
// result in compilation errors.
type UnsafeProxy_13Server interface {
	mustEmbedUnimplementedProxy_13Server()
}

func RegisterProxy_13Server(s grpc.ServiceRegistrar, srv Proxy_13Server) {
	s.RegisterService(&Proxy_13_ServiceDesc, srv)
}

func _Proxy_13_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_13Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_13_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_13Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_13_ServiceDesc is the grpc.ServiceDesc for Proxy_13 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_13_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_13",
	HandlerType: (*Proxy_13Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_13_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_14_Send_FullMethodName = "/msg.Proxy_14/Send"
)

// Proxy_14Client is the client API for Proxy_14 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_14Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_14Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_14Client(cc grpc.ClientConnInterface) Proxy_14Client {
	return &proxy_14Client{cc}
}

func (c *proxy_14Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_14_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_14Server is the server API for Proxy_14 service.
// All implementations must embed UnimplementedProxy_14Server
// for forward compatibility
type Proxy_14Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_14Server()
}

// UnimplementedProxy_14Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_14Server struct {
}

func (UnimplementedProxy_14Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_14Server) mustEmbedUnimplementedProxy_14Server() {}

// UnsafeProxy_14Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_14Server will
// result in compilation errors.
type UnsafeProxy_14Server interface {
	mustEmbedUnimplementedProxy_14Server()
}

func RegisterProxy_14Server(s grpc.ServiceRegistrar, srv Proxy_14Server) {
	s.RegisterService(&Proxy_14_ServiceDesc, srv)
}

func _Proxy_14_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_14Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_14_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_14Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_14_ServiceDesc is the grpc.ServiceDesc for Proxy_14 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_14_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_14",
	HandlerType: (*Proxy_14Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_14_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_15_Send_FullMethodName = "/msg.Proxy_15/Send"
)

// Proxy_15Client is the client API for Proxy_15 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_15Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_15Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_15Client(cc grpc.ClientConnInterface) Proxy_15Client {
	return &proxy_15Client{cc}
}

func (c *proxy_15Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_15_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_15Server is the server API for Proxy_15 service.
// All implementations must embed UnimplementedProxy_15Server
// for forward compatibility
type Proxy_15Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_15Server()
}

// UnimplementedProxy_15Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_15Server struct {
}

func (UnimplementedProxy_15Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_15Server) mustEmbedUnimplementedProxy_15Server() {}

// UnsafeProxy_15Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_15Server will
// result in compilation errors.
type UnsafeProxy_15Server interface {
	mustEmbedUnimplementedProxy_15Server()
}

func RegisterProxy_15Server(s grpc.ServiceRegistrar, srv Proxy_15Server) {
	s.RegisterService(&Proxy_15_ServiceDesc, srv)
}

func _Proxy_15_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_15Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_15_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_15Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_15_ServiceDesc is the grpc.ServiceDesc for Proxy_15 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_15_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_15",
	HandlerType: (*Proxy_15Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_15_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_16_Send_FullMethodName = "/msg.Proxy_16/Send"
)

// Proxy_16Client is the client API for Proxy_16 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type Proxy_16Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type proxy_16Client struct {
	cc grpc.ClientConnInterface
}

func NewProxy_16Client(cc grpc.ClientConnInterface) Proxy_16Client {
	return &proxy_16Client{cc}
}

func (c *proxy_16Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Proxy_16_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Proxy_16Server is the server API for Proxy_16 service.
// All implementations must embed UnimplementedProxy_16Server
// for forward compatibility
type Proxy_16Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedProxy_16Server()
}

// UnimplementedProxy_16Server must be embedded to have forward compatible implementations.
type UnimplementedProxy_16Server struct {
}

func (UnimplementedProxy_16Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedProxy_16Server) mustEmbedUnimplementedProxy_16Server() {}

// UnsafeProxy_16Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to Proxy_16Server will
// result in compilation errors.
type UnsafeProxy_16Server interface {
	mustEmbedUnimplementedProxy_16Server()
}

func RegisterProxy_16Server(s grpc.ServiceRegistrar, srv Proxy_16Server) {
	s.RegisterService(&Proxy_16_ServiceDesc, srv)
}

func _Proxy_16_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Proxy_16Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_16_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Proxy_16Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_16_ServiceDesc is the grpc.ServiceDesc for Proxy_16 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_16_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy_16",
	HandlerType: (*Proxy_16Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Proxy_16_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	Proxy_CoreRouterSend_FullMethodName = "/msg.Proxy/CoreRouterSend"
)

// ProxyClient is the client API for Proxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProxyClient interface {
	// CoreRouterSend processes messages sent by Core-Router
	CoreRouterSend(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*Data, error)
}

type proxyClient struct {
	cc grpc.ClientConnInterface
}

func NewProxyClient(cc grpc.ClientConnInterface) ProxyClient {
	return &proxyClient{cc}
}

func (c *proxyClient) CoreRouterSend(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*Data, error) {
	out := new(Data)
	err := c.cc.Invoke(ctx, Proxy_CoreRouterSend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProxyServer is the server API for Proxy service.
// All implementations must embed UnimplementedProxyServer
// for forward compatibility
type ProxyServer interface {
	// CoreRouterSend processes messages sent by Core-Router
	CoreRouterSend(context.Context, *Transaction) (*Data, error)
	mustEmbedUnimplementedProxyServer()
}

// UnimplementedProxyServer must be embedded to have forward compatible implementations.
type UnimplementedProxyServer struct {
}

func (UnimplementedProxyServer) CoreRouterSend(context.Context, *Transaction) (*Data, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CoreRouterSend not implemented")
}
func (UnimplementedProxyServer) mustEmbedUnimplementedProxyServer() {}

// UnsafeProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProxyServer will
// result in compilation errors.
type UnsafeProxyServer interface {
	mustEmbedUnimplementedProxyServer()
}

func RegisterProxyServer(s grpc.ServiceRegistrar, srv ProxyServer) {
	s.RegisterService(&Proxy_ServiceDesc, srv)
}

func _Proxy_CoreRouterSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProxyServer).CoreRouterSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Proxy_CoreRouterSend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProxyServer).CoreRouterSend(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// Proxy_ServiceDesc is the grpc.ServiceDesc for Proxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Proxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.Proxy",
	HandlerType: (*ProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CoreRouterSend",
			Handler:    _Proxy_CoreRouterSend_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	IPC1NOS_Send_FullMethodName = "/msg.IPC1NOS/Send"
)

// IPC1NOSClient is the client API for IPC1NOS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IPC1NOSClient interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type iPC1NOSClient struct {
	cc grpc.ClientConnInterface
}

func NewIPC1NOSClient(cc grpc.ClientConnInterface) IPC1NOSClient {
	return &iPC1NOSClient{cc}
}

func (c *iPC1NOSClient) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, IPC1NOS_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IPC1NOSServer is the server API for IPC1NOS service.
// All implementations must embed UnimplementedIPC1NOSServer
// for forward compatibility
type IPC1NOSServer interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedIPC1NOSServer()
}

// UnimplementedIPC1NOSServer must be embedded to have forward compatible implementations.
type UnimplementedIPC1NOSServer struct {
}

func (UnimplementedIPC1NOSServer) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedIPC1NOSServer) mustEmbedUnimplementedIPC1NOSServer() {}

// UnsafeIPC1NOSServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IPC1NOSServer will
// result in compilation errors.
type UnsafeIPC1NOSServer interface {
	mustEmbedUnimplementedIPC1NOSServer()
}

func RegisterIPC1NOSServer(s grpc.ServiceRegistrar, srv IPC1NOSServer) {
	s.RegisterService(&IPC1NOS_ServiceDesc, srv)
}

func _IPC1NOS_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPC1NOSServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPC1NOS_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPC1NOSServer).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// IPC1NOS_ServiceDesc is the grpc.ServiceDesc for IPC1NOS service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IPC1NOS_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.IPC1NOS",
	HandlerType: (*IPC1NOSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _IPC1NOS_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	IPC2NOS_Send_FullMethodName = "/msg.IPC2NOS/Send"
)

// IPC2NOSClient is the client API for IPC2NOS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IPC2NOSClient interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type iPC2NOSClient struct {
	cc grpc.ClientConnInterface
}

func NewIPC2NOSClient(cc grpc.ClientConnInterface) IPC2NOSClient {
	return &iPC2NOSClient{cc}
}

func (c *iPC2NOSClient) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, IPC2NOS_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IPC2NOSServer is the server API for IPC2NOS service.
// All implementations must embed UnimplementedIPC2NOSServer
// for forward compatibility
type IPC2NOSServer interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedIPC2NOSServer()
}

// UnimplementedIPC2NOSServer must be embedded to have forward compatible implementations.
type UnimplementedIPC2NOSServer struct {
}

func (UnimplementedIPC2NOSServer) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedIPC2NOSServer) mustEmbedUnimplementedIPC2NOSServer() {}

// UnsafeIPC2NOSServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IPC2NOSServer will
// result in compilation errors.
type UnsafeIPC2NOSServer interface {
	mustEmbedUnimplementedIPC2NOSServer()
}

func RegisterIPC2NOSServer(s grpc.ServiceRegistrar, srv IPC2NOSServer) {
	s.RegisterService(&IPC2NOS_ServiceDesc, srv)
}

func _IPC2NOS_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IPC2NOSServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: IPC2NOS_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IPC2NOSServer).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// IPC2NOS_ServiceDesc is the grpc.ServiceDesc for IPC2NOS service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IPC2NOS_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.IPC2NOS",
	HandlerType: (*IPC2NOSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _IPC2NOS_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebClient_Send_FullMethodName = "/msg.WebClient/Send"
)

// WebClientClient is the client API for WebClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebClientClient interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webClientClient struct {
	cc grpc.ClientConnInterface
}

func NewWebClientClient(cc grpc.ClientConnInterface) WebClientClient {
	return &webClientClient{cc}
}

func (c *webClientClient) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebClient_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebClientServer is the server API for WebClient service.
// All implementations must embed UnimplementedWebClientServer
// for forward compatibility
type WebClientServer interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebClientServer()
}

// UnimplementedWebClientServer must be embedded to have forward compatible implementations.
type UnimplementedWebClientServer struct {
}

func (UnimplementedWebClientServer) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebClientServer) mustEmbedUnimplementedWebClientServer() {}

// UnsafeWebClientServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebClientServer will
// result in compilation errors.
type UnsafeWebClientServer interface {
	mustEmbedUnimplementedWebClientServer()
}

func RegisterWebClientServer(s grpc.ServiceRegistrar, srv WebClientServer) {
	s.RegisterService(&WebClient_ServiceDesc, srv)
}

func _WebClient_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebClientServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebClient_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebClientServer).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebClient_ServiceDesc is the grpc.ServiceDesc for WebClient service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebClient_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebClient",
	HandlerType: (*WebClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebClient_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_Send_FullMethodName = "/msg.WebProxy/Send"
)

// WebProxyClient is the client API for WebProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxyClient interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxyClient struct {
	cc grpc.ClientConnInterface
}

func NewWebProxyClient(cc grpc.ClientConnInterface) WebProxyClient {
	return &webProxyClient{cc}
}

func (c *webProxyClient) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxyServer is the server API for WebProxy service.
// All implementations must embed UnimplementedWebProxyServer
// for forward compatibility
type WebProxyServer interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxyServer()
}

// UnimplementedWebProxyServer must be embedded to have forward compatible implementations.
type UnimplementedWebProxyServer struct {
}

func (UnimplementedWebProxyServer) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxyServer) mustEmbedUnimplementedWebProxyServer() {}

// UnsafeWebProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxyServer will
// result in compilation errors.
type UnsafeWebProxyServer interface {
	mustEmbedUnimplementedWebProxyServer()
}

func RegisterWebProxyServer(s grpc.ServiceRegistrar, srv WebProxyServer) {
	s.RegisterService(&WebProxy_ServiceDesc, srv)
}

func _WebProxy_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxyServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxyServer).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_ServiceDesc is the grpc.ServiceDesc for WebProxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy",
	HandlerType: (*WebProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_1_Send_FullMethodName = "/msg.WebProxy_1/Send"
)

// WebProxy_1Client is the client API for WebProxy_1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_1Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_1Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_1Client(cc grpc.ClientConnInterface) WebProxy_1Client {
	return &webProxy_1Client{cc}
}

func (c *webProxy_1Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_1_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_1Server is the server API for WebProxy_1 service.
// All implementations must embed UnimplementedWebProxy_1Server
// for forward compatibility
type WebProxy_1Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_1Server()
}

// UnimplementedWebProxy_1Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_1Server struct {
}

func (UnimplementedWebProxy_1Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_1Server) mustEmbedUnimplementedWebProxy_1Server() {}

// UnsafeWebProxy_1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_1Server will
// result in compilation errors.
type UnsafeWebProxy_1Server interface {
	mustEmbedUnimplementedWebProxy_1Server()
}

func RegisterWebProxy_1Server(s grpc.ServiceRegistrar, srv WebProxy_1Server) {
	s.RegisterService(&WebProxy_1_ServiceDesc, srv)
}

func _WebProxy_1_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_1Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_1_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_1Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_1_ServiceDesc is the grpc.ServiceDesc for WebProxy_1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_1_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_1",
	HandlerType: (*WebProxy_1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_1_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_2_Send_FullMethodName = "/msg.WebProxy_2/Send"
)

// WebProxy_2Client is the client API for WebProxy_2 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_2Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_2Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_2Client(cc grpc.ClientConnInterface) WebProxy_2Client {
	return &webProxy_2Client{cc}
}

func (c *webProxy_2Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_2_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_2Server is the server API for WebProxy_2 service.
// All implementations must embed UnimplementedWebProxy_2Server
// for forward compatibility
type WebProxy_2Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_2Server()
}

// UnimplementedWebProxy_2Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_2Server struct {
}

func (UnimplementedWebProxy_2Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_2Server) mustEmbedUnimplementedWebProxy_2Server() {}

// UnsafeWebProxy_2Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_2Server will
// result in compilation errors.
type UnsafeWebProxy_2Server interface {
	mustEmbedUnimplementedWebProxy_2Server()
}

func RegisterWebProxy_2Server(s grpc.ServiceRegistrar, srv WebProxy_2Server) {
	s.RegisterService(&WebProxy_2_ServiceDesc, srv)
}

func _WebProxy_2_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_2Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_2_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_2Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_2_ServiceDesc is the grpc.ServiceDesc for WebProxy_2 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_2_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_2",
	HandlerType: (*WebProxy_2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_2_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_3_Send_FullMethodName = "/msg.WebProxy_3/Send"
)

// WebProxy_3Client is the client API for WebProxy_3 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_3Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_3Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_3Client(cc grpc.ClientConnInterface) WebProxy_3Client {
	return &webProxy_3Client{cc}
}

func (c *webProxy_3Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_3_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_3Server is the server API for WebProxy_3 service.
// All implementations must embed UnimplementedWebProxy_3Server
// for forward compatibility
type WebProxy_3Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_3Server()
}

// UnimplementedWebProxy_3Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_3Server struct {
}

func (UnimplementedWebProxy_3Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_3Server) mustEmbedUnimplementedWebProxy_3Server() {}

// UnsafeWebProxy_3Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_3Server will
// result in compilation errors.
type UnsafeWebProxy_3Server interface {
	mustEmbedUnimplementedWebProxy_3Server()
}

func RegisterWebProxy_3Server(s grpc.ServiceRegistrar, srv WebProxy_3Server) {
	s.RegisterService(&WebProxy_3_ServiceDesc, srv)
}

func _WebProxy_3_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_3Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_3_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_3Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_3_ServiceDesc is the grpc.ServiceDesc for WebProxy_3 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_3_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_3",
	HandlerType: (*WebProxy_3Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_3_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_4_Send_FullMethodName = "/msg.WebProxy_4/Send"
)

// WebProxy_4Client is the client API for WebProxy_4 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_4Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_4Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_4Client(cc grpc.ClientConnInterface) WebProxy_4Client {
	return &webProxy_4Client{cc}
}

func (c *webProxy_4Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_4_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_4Server is the server API for WebProxy_4 service.
// All implementations must embed UnimplementedWebProxy_4Server
// for forward compatibility
type WebProxy_4Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_4Server()
}

// UnimplementedWebProxy_4Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_4Server struct {
}

func (UnimplementedWebProxy_4Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_4Server) mustEmbedUnimplementedWebProxy_4Server() {}

// UnsafeWebProxy_4Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_4Server will
// result in compilation errors.
type UnsafeWebProxy_4Server interface {
	mustEmbedUnimplementedWebProxy_4Server()
}

func RegisterWebProxy_4Server(s grpc.ServiceRegistrar, srv WebProxy_4Server) {
	s.RegisterService(&WebProxy_4_ServiceDesc, srv)
}

func _WebProxy_4_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_4Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_4_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_4Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_4_ServiceDesc is the grpc.ServiceDesc for WebProxy_4 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_4_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_4",
	HandlerType: (*WebProxy_4Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_4_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_5_Send_FullMethodName = "/msg.WebProxy_5/Send"
)

// WebProxy_5Client is the client API for WebProxy_5 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_5Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_5Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_5Client(cc grpc.ClientConnInterface) WebProxy_5Client {
	return &webProxy_5Client{cc}
}

func (c *webProxy_5Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_5_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_5Server is the server API for WebProxy_5 service.
// All implementations must embed UnimplementedWebProxy_5Server
// for forward compatibility
type WebProxy_5Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_5Server()
}

// UnimplementedWebProxy_5Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_5Server struct {
}

func (UnimplementedWebProxy_5Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_5Server) mustEmbedUnimplementedWebProxy_5Server() {}

// UnsafeWebProxy_5Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_5Server will
// result in compilation errors.
type UnsafeWebProxy_5Server interface {
	mustEmbedUnimplementedWebProxy_5Server()
}

func RegisterWebProxy_5Server(s grpc.ServiceRegistrar, srv WebProxy_5Server) {
	s.RegisterService(&WebProxy_5_ServiceDesc, srv)
}

func _WebProxy_5_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_5Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_5_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_5Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_5_ServiceDesc is the grpc.ServiceDesc for WebProxy_5 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_5_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_5",
	HandlerType: (*WebProxy_5Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_5_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_6_Send_FullMethodName = "/msg.WebProxy_6/Send"
)

// WebProxy_6Client is the client API for WebProxy_6 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_6Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_6Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_6Client(cc grpc.ClientConnInterface) WebProxy_6Client {
	return &webProxy_6Client{cc}
}

func (c *webProxy_6Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_6_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_6Server is the server API for WebProxy_6 service.
// All implementations must embed UnimplementedWebProxy_6Server
// for forward compatibility
type WebProxy_6Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_6Server()
}

// UnimplementedWebProxy_6Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_6Server struct {
}

func (UnimplementedWebProxy_6Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_6Server) mustEmbedUnimplementedWebProxy_6Server() {}

// UnsafeWebProxy_6Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_6Server will
// result in compilation errors.
type UnsafeWebProxy_6Server interface {
	mustEmbedUnimplementedWebProxy_6Server()
}

func RegisterWebProxy_6Server(s grpc.ServiceRegistrar, srv WebProxy_6Server) {
	s.RegisterService(&WebProxy_6_ServiceDesc, srv)
}

func _WebProxy_6_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_6Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_6_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_6Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_6_ServiceDesc is the grpc.ServiceDesc for WebProxy_6 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_6_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_6",
	HandlerType: (*WebProxy_6Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_6_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_7_Send_FullMethodName = "/msg.WebProxy_7/Send"
)

// WebProxy_7Client is the client API for WebProxy_7 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_7Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_7Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_7Client(cc grpc.ClientConnInterface) WebProxy_7Client {
	return &webProxy_7Client{cc}
}

func (c *webProxy_7Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_7_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_7Server is the server API for WebProxy_7 service.
// All implementations must embed UnimplementedWebProxy_7Server
// for forward compatibility
type WebProxy_7Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_7Server()
}

// UnimplementedWebProxy_7Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_7Server struct {
}

func (UnimplementedWebProxy_7Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_7Server) mustEmbedUnimplementedWebProxy_7Server() {}

// UnsafeWebProxy_7Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_7Server will
// result in compilation errors.
type UnsafeWebProxy_7Server interface {
	mustEmbedUnimplementedWebProxy_7Server()
}

func RegisterWebProxy_7Server(s grpc.ServiceRegistrar, srv WebProxy_7Server) {
	s.RegisterService(&WebProxy_7_ServiceDesc, srv)
}

func _WebProxy_7_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_7Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_7_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_7Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_7_ServiceDesc is the grpc.ServiceDesc for WebProxy_7 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_7_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_7",
	HandlerType: (*WebProxy_7Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_7_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_8_Send_FullMethodName = "/msg.WebProxy_8/Send"
)

// WebProxy_8Client is the client API for WebProxy_8 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_8Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_8Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_8Client(cc grpc.ClientConnInterface) WebProxy_8Client {
	return &webProxy_8Client{cc}
}

func (c *webProxy_8Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_8_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_8Server is the server API for WebProxy_8 service.
// All implementations must embed UnimplementedWebProxy_8Server
// for forward compatibility
type WebProxy_8Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_8Server()
}

// UnimplementedWebProxy_8Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_8Server struct {
}

func (UnimplementedWebProxy_8Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_8Server) mustEmbedUnimplementedWebProxy_8Server() {}

// UnsafeWebProxy_8Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_8Server will
// result in compilation errors.
type UnsafeWebProxy_8Server interface {
	mustEmbedUnimplementedWebProxy_8Server()
}

func RegisterWebProxy_8Server(s grpc.ServiceRegistrar, srv WebProxy_8Server) {
	s.RegisterService(&WebProxy_8_ServiceDesc, srv)
}

func _WebProxy_8_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_8Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_8_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_8Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_8_ServiceDesc is the grpc.ServiceDesc for WebProxy_8 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_8_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_8",
	HandlerType: (*WebProxy_8Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_8_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_9_Send_FullMethodName = "/msg.WebProxy_9/Send"
)

// WebProxy_9Client is the client API for WebProxy_9 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_9Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_9Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_9Client(cc grpc.ClientConnInterface) WebProxy_9Client {
	return &webProxy_9Client{cc}
}

func (c *webProxy_9Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_9_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_9Server is the server API for WebProxy_9 service.
// All implementations must embed UnimplementedWebProxy_9Server
// for forward compatibility
type WebProxy_9Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_9Server()
}

// UnimplementedWebProxy_9Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_9Server struct {
}

func (UnimplementedWebProxy_9Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_9Server) mustEmbedUnimplementedWebProxy_9Server() {}

// UnsafeWebProxy_9Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_9Server will
// result in compilation errors.
type UnsafeWebProxy_9Server interface {
	mustEmbedUnimplementedWebProxy_9Server()
}

func RegisterWebProxy_9Server(s grpc.ServiceRegistrar, srv WebProxy_9Server) {
	s.RegisterService(&WebProxy_9_ServiceDesc, srv)
}

func _WebProxy_9_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_9Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_9_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_9Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_9_ServiceDesc is the grpc.ServiceDesc for WebProxy_9 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_9_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_9",
	HandlerType: (*WebProxy_9Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_9_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	WebProxy_10_Send_FullMethodName = "/msg.WebProxy_10/Send"
)

// WebProxy_10Client is the client API for WebProxy_10 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WebProxy_10Client interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type webProxy_10Client struct {
	cc grpc.ClientConnInterface
}

func NewWebProxy_10Client(cc grpc.ClientConnInterface) WebProxy_10Client {
	return &webProxy_10Client{cc}
}

func (c *webProxy_10Client) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WebProxy_10_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WebProxy_10Server is the server API for WebProxy_10 service.
// All implementations must embed UnimplementedWebProxy_10Server
// for forward compatibility
type WebProxy_10Server interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	mustEmbedUnimplementedWebProxy_10Server()
}

// UnimplementedWebProxy_10Server must be embedded to have forward compatible implementations.
type UnimplementedWebProxy_10Server struct {
}

func (UnimplementedWebProxy_10Server) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedWebProxy_10Server) mustEmbedUnimplementedWebProxy_10Server() {}

// UnsafeWebProxy_10Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WebProxy_10Server will
// result in compilation errors.
type UnsafeWebProxy_10Server interface {
	mustEmbedUnimplementedWebProxy_10Server()
}

func RegisterWebProxy_10Server(s grpc.ServiceRegistrar, srv WebProxy_10Server) {
	s.RegisterService(&WebProxy_10_ServiceDesc, srv)
}

func _WebProxy_10_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebProxy_10Server).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WebProxy_10_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebProxy_10Server).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

// WebProxy_10_ServiceDesc is the grpc.ServiceDesc for WebProxy_10 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WebProxy_10_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.WebProxy_10",
	HandlerType: (*WebProxy_10Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _WebProxy_10_Send_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}

const (
	CoreRouter_Send_FullMethodName                  = "/msg.CoreRouter/Send"
	CoreRouter_NosSend_FullMethodName               = "/msg.CoreRouter/NosSend"
	CoreRouter_ProxySend_FullMethodName             = "/msg.CoreRouter/ProxySend"
	CoreRouter_ProcessMsgFromRemote_FullMethodName  = "/msg.CoreRouter/ProcessMsgFromRemote"
	CoreRouter_ProcessRemoteCSMEvent_FullMethodName = "/msg.CoreRouter/ProcessRemoteCSMEvent"
)

// CoreRouterClient is the client API for CoreRouter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CoreRouterClient interface {
	Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
	NosSend(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ProxySend(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ProcessMsgFromRemote(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ProcessRemoteCSMEvent(ctx context.Context, in *CSMEvent, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type coreRouterClient struct {
	cc grpc.ClientConnInterface
}

func NewCoreRouterClient(cc grpc.ClientConnInterface) CoreRouterClient {
	return &coreRouterClient{cc}
}

func (c *coreRouterClient) Send(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CoreRouter_Send_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreRouterClient) NosSend(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CoreRouter_NosSend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreRouterClient) ProxySend(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CoreRouter_ProxySend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreRouterClient) ProcessMsgFromRemote(ctx context.Context, in *Transaction, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CoreRouter_ProcessMsgFromRemote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreRouterClient) ProcessRemoteCSMEvent(ctx context.Context, in *CSMEvent, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CoreRouter_ProcessRemoteCSMEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoreRouterServer is the server API for CoreRouter service.
// All implementations must embed UnimplementedCoreRouterServer
// for forward compatibility
type CoreRouterServer interface {
	Send(context.Context, *Transaction) (*emptypb.Empty, error)
	NosSend(context.Context, *Transaction) (*emptypb.Empty, error)
	ProxySend(context.Context, *Transaction) (*emptypb.Empty, error)
	ProcessMsgFromRemote(context.Context, *Transaction) (*emptypb.Empty, error)
	ProcessRemoteCSMEvent(context.Context, *CSMEvent) (*emptypb.Empty, error)
	mustEmbedUnimplementedCoreRouterServer()
}

// UnimplementedCoreRouterServer must be embedded to have forward compatible implementations.
type UnimplementedCoreRouterServer struct {
}

func (UnimplementedCoreRouterServer) Send(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (UnimplementedCoreRouterServer) NosSend(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NosSend not implemented")
}
func (UnimplementedCoreRouterServer) ProxySend(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProxySend not implemented")
}
func (UnimplementedCoreRouterServer) ProcessMsgFromRemote(context.Context, *Transaction) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessMsgFromRemote not implemented")
}
func (UnimplementedCoreRouterServer) ProcessRemoteCSMEvent(context.Context, *CSMEvent) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessRemoteCSMEvent not implemented")
}
func (UnimplementedCoreRouterServer) mustEmbedUnimplementedCoreRouterServer() {}

// UnsafeCoreRouterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CoreRouterServer will
// result in compilation errors.
type UnsafeCoreRouterServer interface {
	mustEmbedUnimplementedCoreRouterServer()
}

func RegisterCoreRouterServer(s grpc.ServiceRegistrar, srv CoreRouterServer) {
	s.RegisterService(&CoreRouter_ServiceDesc, srv)
}

func _CoreRouter_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreRouterServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoreRouter_Send_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreRouterServer).Send(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreRouter_NosSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreRouterServer).NosSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoreRouter_NosSend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreRouterServer).NosSend(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreRouter_ProxySend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreRouterServer).ProxySend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoreRouter_ProxySend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreRouterServer).ProxySend(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreRouter_ProcessMsgFromRemote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transaction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreRouterServer).ProcessMsgFromRemote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoreRouter_ProcessMsgFromRemote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreRouterServer).ProcessMsgFromRemote(ctx, req.(*Transaction))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoreRouter_ProcessRemoteCSMEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSMEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreRouterServer).ProcessRemoteCSMEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CoreRouter_ProcessRemoteCSMEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreRouterServer).ProcessRemoteCSMEvent(ctx, req.(*CSMEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// CoreRouter_ServiceDesc is the grpc.ServiceDesc for CoreRouter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CoreRouter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "msg.CoreRouter",
	HandlerType: (*CoreRouterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _CoreRouter_Send_Handler,
		},
		{
			MethodName: "NosSend",
			Handler:    _CoreRouter_NosSend_Handler,
		},
		{
			MethodName: "ProxySend",
			Handler:    _CoreRouter_ProxySend_Handler,
		},
		{
			MethodName: "ProcessMsgFromRemote",
			Handler:    _CoreRouter_ProcessMsgFromRemote_Handler,
		},
		{
			MethodName: "ProcessRemoteCSMEvent",
			Handler:    _CoreRouter_ProcessRemoteCSMEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/shadow.proto",
}
